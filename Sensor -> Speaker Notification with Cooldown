blueprint:
  name: Sensor -> Speaker Notification with Cooldown & Restore
  description: >
    Send a TTS notification to one or more speakers when a sensor is tripped,
    with a cooldown period between alerts. If the speakers were already
    playing audio, their previous playback and volume are restored afterwards.
  domain: automation
  source_url: https://example.com/sensor_speaker_cooldown_restore
  input:
    trigger_sensor:
      name: Sensor to monitor
      description: Binary sensor that triggers the notification (e.g. door, PIR).
      selector:
        entity:
          domain: binary_sensor

    media_player:
      name: Speaker(s)
      description: One or more speakers / media_players to use for the spoken notification.
      selector:
        entity:
          domain: media_player
          multiple: true

    cooldown_minutes:
      name: Cooldown (minutes)
      description: >
        Minimum time between spoken notifications for this automation.
      default: 5
      selector:
        number:
          min: 0
          max: 1440
          unit_of_measurement: minutes
          mode: slider
          step: 1

    tts_message:
      name: TTS Message
      description: >
        Message to speak when the sensor is tripped.
      default: "Warning: the sensor has been triggered."
      selector:
        text: {}

    volume_level:
      name: Volume (optional)
      description: >
        Volume to set on the speaker(s) before speaking (0.0â€“1.0).
        Leave empty to skip changing volume.
      default:
      selector:
        number:
          min: 0
          max: 1
          step: 0.05
          mode: slider

    tts_service:
      name: TTS Service
      description: >
        TTS service to use for speech (e.g. tts.google_translate_say,
        tts.cloud_say, etc.).
      default: tts.cloud_say
      selector:
        text: {}

mode: single
max_exceeded: silent

variables:
  cooldown_minutes: !input cooldown_minutes
  cooldown_secs: "{{ (cooldown_minutes | int(0)) * 60 }}"
  msg: !input tts_message
  vol: !input volume_level
  players: !input media_player
  tts_service: !input tts_service

trigger:
  - platform: state
    entity_id: !input trigger_sensor
    from: "off"
    to: "on"

# Cooldown: only run if enough time has passed since last trigger
condition:
  - condition: template
    value_template: >
      {% set lt = state_attr(this.entity_id, 'last_triggered') %}
      {% if lt is none %}
        true
      {% else %}
        {{ (as_timestamp(now()) - as_timestamp(lt)) > cooldown_secs }}
      {% endif %}

action:
  # Take a snapshot of the current state of the speaker(s) so we can restore it later.
  - service: media_player.snapshot
    target:
      entity_id: !input media_player
    data:
      with_group: true

  # Optionally change volume for the TTS
  - choose:
      - conditions: "{{ vol is not none }}"
        sequence:
          - service: media_player.volume_set
            target:
              entity_id: !input media_player
            data:
              volume_level: "{{ vol | float }}"

  # Speak the message using the chosen TTS service
  - service: "{{ tts_service }}"
    target:
      entity_id: !input media_player
    data:
      message: "{{ msg }}"

  # Wait for TTS to finish (speaker usually goes to idle/off after playing)
  - wait_for_trigger:
      - platform: state
        entity_id: !input media_player
        to: "idle"
      - platform: state
        entity_id: !input media_player
        to: "off"
    timeout: "00:00:20"
    continue_on_timeout: true

  # Restore previous playback and volume on the speaker(s)
  - service: media_player.restore
    target:
      entity_id: !input media_player
    data:
      with_group: true
